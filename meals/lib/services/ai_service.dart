import 'dart:convert';
import 'package:http/http.dart' as http;
import '../data/models/user_api_key.dart';

/// Structured meal data generated by AI
class GeneratedMeal {
  final String name;
  final String description;
  final String mealType;
  final int calories;
  final int prepTime;
  final int cookTime;
  final String difficulty;
  final String cuisine;
  final String dietType;
  final List<String> ingredients;
  final List<String> instructions;
  final Map<String, double> nutrition;
  final List<String> tags;
  final String? imageSearchTerm;

  GeneratedMeal({
    required this.name,
    required this.description,
    required this.mealType,
    required this.calories,
    required this.prepTime,
    required this.cookTime,
    required this.difficulty,
    required this.cuisine,
    required this.dietType,
    required this.ingredients,
    required this.instructions,
    required this.nutrition,
    required this.tags,
    this.imageSearchTerm,
  });

  factory GeneratedMeal.fromJson(Map<String, dynamic> json) {
    return GeneratedMeal(
      name: json['name'] ?? '',
      description: json['description'] ?? '',
      mealType: json['meal_type'] ?? 'dinner',
      calories: json['calories'] ?? 0,
      prepTime: json['prep_time'] ?? 0,
      cookTime: json['cook_time'] ?? 0,
      difficulty: json['difficulty'] ?? 'Easy',
      cuisine: json['cuisine'] ?? 'International',
      dietType: json['diet_type'] ?? 'None',
      ingredients: List<String>.from(json['ingredients'] ?? []),
      instructions: List<String>.from(json['instructions'] ?? []),
      nutrition: Map<String, double>.from(
        (json['nutrition'] ?? {}).map(
          (k, v) => MapEntry(k, (v as num).toDouble()),
        ),
      ),
      tags: List<String>.from(json['tags'] ?? []),
      imageSearchTerm: json['image_search_term'],
    );
  }

  Map<String, dynamic> toJson() => {
    'name': name,
    'description': description,
    'meal_type': mealType,
    'calories': calories,
    'prep_time': prepTime,
    'cook_time': cookTime,
    'difficulty': difficulty,
    'cuisine': cuisine,
    'diet_type': dietType,
    'ingredients': ingredients,
    'instructions': instructions,
    'nutrition': nutrition,
    'tags': tags,
    'image_search_term': imageSearchTerm,
  };
}

class AIService {
  // Current provider settings
  AIProviderType _provider = AIProviderType.openRouter;
  String? _apiKey;

  AIService({String? apiKey, AIProviderType? provider})
    : _apiKey = apiKey,
      _provider = provider ?? AIProviderType.openRouter;

  void setApiKey(String apiKey) {
    _apiKey = apiKey;
  }

  void setProvider(AIProviderType provider) {
    _provider = provider;
  }

  bool get hasApiKey => _apiKey != null && _apiKey!.isNotEmpty;

  /// Generate new meals based on user preferences
  /// Returns structured meal data ready for database insertion
  Future<List<GeneratedMeal>> discoverMeals({
    required String dietType,
    required List<String> allergies,
    required List<String> cuisinePreferences,
    int householdSize = 1,
    String cookingExperience = 'Intermediate',
    List<String> nutritionGoals = const [],
    List<String> dislikedIngredients = const [],
    int count = 5,
  }) async {
    final prompt = _buildMealGenerationPrompt(
      dietType: dietType,
      allergies: allergies,
      cuisinePreferences: cuisinePreferences,
      householdSize: householdSize,
      cookingExperience: cookingExperience,
      nutritionGoals: nutritionGoals,
      dislikedIngredients: dislikedIngredients,
      count: count,
    );

    final response = await _makeRequest(prompt);
    return _parseMealsFromResponse(response);
  }

  /// Generate meals for a specific meal type
  Future<List<GeneratedMeal>> discoverMealsByType({
    required String mealType,
    required String dietType,
    required List<String> allergies,
    required List<String> cuisinePreferences,
    int householdSize = 1,
    String cookingExperience = 'Intermediate',
    List<String> nutritionGoals = const [],
    List<String> dislikedIngredients = const [],
    int count = 3,
  }) async {
    final prompt = _buildMealTypePrompt(
      mealType: mealType,
      dietType: dietType,
      allergies: allergies,
      cuisinePreferences: cuisinePreferences,
      householdSize: householdSize,
      cookingExperience: cookingExperience,
      nutritionGoals: nutritionGoals,
      dislikedIngredients: dislikedIngredients,
      count: count,
    );

    final response = await _makeRequest(prompt);
    return _parseMealsFromResponse(response);
  }

  /// Generate meals with a custom prompt
  Future<List<GeneratedMeal>> discoverMealsWithPrompt({
    required String prompt,
    required String dietType,
    required List<String> allergies,
    int householdSize = 1,
    int count = 3,
  }) async {
    final fullPrompt = _buildCustomPrompt(
      customRequest: prompt,
      dietType: dietType,
      allergies: allergies,
      householdSize: householdSize,
      count: count,
    );

    final response = await _makeRequest(fullPrompt);
    return _parseMealsFromResponse(response);
  }

  String _buildMealGenerationPrompt({
    required String dietType,
    required List<String> allergies,
    required List<String> cuisinePreferences,
    required int householdSize,
    required String cookingExperience,
    required List<String> nutritionGoals,
    required List<String> dislikedIngredients,
    required int count,
  }) {
    return '''
Generate $count unique, restaurant-quality meal recipes as a JSON array.

USER PROFILE:
- Household size: $householdSize ${householdSize == 1 ? 'person' : 'people'}
- Cooking experience: $cookingExperience
- Diet: ${dietType == 'None' ? 'No restrictions' : dietType}
- Allergies (MUST EXCLUDE): ${allergies.isEmpty ? 'None' : allergies.join(', ')}
- Disliked ingredients (AVOID): ${dislikedIngredients.isEmpty ? 'None' : dislikedIngredients.join(', ')}
- Preferred cuisines: ${cuisinePreferences.isEmpty ? 'Diverse mix' : cuisinePreferences.join(', ')}
- Nutrition goals: ${nutritionGoals.isEmpty ? 'Balanced' : nutritionGoals.join(', ')}

REQUIREMENTS:
- Include variety: mix of breakfast, lunch, dinner, snacks
- Scale portions for $householdSize ${householdSize == 1 ? 'person' : 'people'}
- Match difficulty to $cookingExperience level
- Each meal must have complete, accurate nutritional data
- Ingredients must include precise measurements
- Instructions must be clear, numbered steps
- Calories must be realistic (not rounded to 100s)
${nutritionGoals.isNotEmpty ? '- Prioritize ${nutritionGoals.join(', ')} in nutrition profile' : ''}

RESPOND WITH ONLY A VALID JSON ARRAY, NO OTHER TEXT:
[
  {
    "name": "Dish Name",
    "description": "2-3 sentence appetizing description",
    "meal_type": "breakfast|lunch|dinner|snack",
    "calories": 425,
    "prep_time": 15,
    "cook_time": 20,
    "difficulty": "Easy|Medium|Hard",
    "cuisine": "Italian|Mexican|Asian|Indian|American|Mediterranean|etc",
    "diet_type": "None|Vegetarian|Vegan|Keto|Paleo|Gluten-Free",
    "ingredients": [
      "200g chicken breast",
      "1 tbsp olive oil",
      "2 cloves garlic, minced"
    ],
    "instructions": [
      "Preheat oven to 180°C (350°F)",
      "Season chicken with salt and pepper",
      "Heat oil in oven-safe pan over medium-high heat"
    ],
    "nutrition": {
      "protein": 35.5,
      "carbs": 12.0,
      "fat": 18.2,
      "fiber": 3.5,
      "sugar": 2.1
    },
    "tags": ["high-protein", "quick", "meal-prep-friendly"],
    "image_search_term": "grilled chicken vegetables plate"
  }
]
''';
  }

  String _buildMealTypePrompt({
    required String mealType,
    required String dietType,
    required List<String> allergies,
    required List<String> cuisinePreferences,
    required int householdSize,
    required String cookingExperience,
    required List<String> nutritionGoals,
    required List<String> dislikedIngredients,
    required int count,
  }) {
    return '''
Generate $count unique $mealType recipes as a JSON array.

USER PROFILE:
- Household size: $householdSize ${householdSize == 1 ? 'person' : 'people'}
- Cooking experience: $cookingExperience
- Diet: ${dietType == 'None' ? 'No restrictions' : dietType}
- Allergies (MUST EXCLUDE): ${allergies.isEmpty ? 'None' : allergies.join(', ')}
- Disliked ingredients (AVOID): ${dislikedIngredients.isEmpty ? 'None' : dislikedIngredients.join(', ')}
- Preferred cuisines: ${cuisinePreferences.isEmpty ? 'Diverse mix' : cuisinePreferences.join(', ')}
- Nutrition goals: ${nutritionGoals.isEmpty ? 'Balanced' : nutritionGoals.join(', ')}

REQUIREMENTS FOR ${mealType.toUpperCase()}:
${_getMealTypeRequirements(mealType)}
- Scale portions for $householdSize ${householdSize == 1 ? 'person' : 'people'}
- Match difficulty to $cookingExperience level
- Complete nutritional data with realistic values
- Precise ingredient measurements
- Clear step-by-step instructions
${nutritionGoals.isNotEmpty ? '- Prioritize ${nutritionGoals.join(', ')} in nutrition profile' : ''}

RESPOND WITH ONLY A VALID JSON ARRAY, NO OTHER TEXT:
[
  {
    "name": "Dish Name",
    "description": "2-3 sentence appetizing description",
    "meal_type": "$mealType",
    "calories": 425,
    "prep_time": 15,
    "cook_time": 20,
    "difficulty": "Easy|Medium|Hard",
    "cuisine": "Cuisine type",
    "diet_type": "${dietType == 'None' ? 'None' : dietType}",
    "ingredients": ["200g ingredient", "1 tbsp ingredient"],
    "instructions": ["Step 1", "Step 2", "Step 3"],
    "nutrition": {
      "protein": 35.5,
      "carbs": 12.0,
      "fat": 18.2,
      "fiber": 3.5,
      "sugar": 2.1
    },
    "tags": ["tag1", "tag2"],
    "image_search_term": "descriptive food image search"
  }
]
''';
  }

  String _getMealTypeRequirements(String mealType) {
    switch (mealType.toLowerCase()) {
      case 'breakfast':
        return '''- Quick to prepare (under 20 mins ideal)
- Energizing, good balance of protein and carbs
- 300-500 calories typical range''';
      case 'lunch':
        return '''- Balanced nutrition for sustained energy
- Can include meal-prep friendly options
- 400-700 calories typical range''';
      case 'dinner':
        return '''- More elaborate recipes acceptable
- Satisfying portions, family-friendly options
- 500-800 calories typical range''';
      case 'snack':
        return '''- Quick, minimal preparation
- Portion controlled
- 100-300 calories typical range''';
      default:
        return '- Well-balanced nutritional profile';
    }
  }

  String _buildCustomPrompt({
    required String customRequest,
    required String dietType,
    required List<String> allergies,
    required int householdSize,
    required int count,
  }) {
    return '''
Generate $count unique meal recipes based on this request: "$customRequest"

USER PROFILE:
- Household size: $householdSize ${householdSize == 1 ? 'person' : 'people'}
- Diet: ${dietType == 'None' ? 'No restrictions' : dietType}
- Allergies (MUST EXCLUDE): ${allergies.isEmpty ? 'None' : allergies.join(', ')}

REQUIREMENTS:
- Create meals that match the user's request
- Scale portions for $householdSize ${householdSize == 1 ? 'person' : 'people'}
- Complete nutritional data with realistic values
- Precise ingredient measurements
- Clear step-by-step instructions

RESPOND WITH ONLY A VALID JSON ARRAY, NO OTHER TEXT:
[
  {
    "name": "Dish Name",
    "description": "2-3 sentence appetizing description",
    "meal_type": "breakfast|lunch|dinner|snack",
    "calories": 425,
    "prep_time": 15,
    "cook_time": 20,
    "difficulty": "Easy|Medium|Hard",
    "cuisine": "Cuisine type",
    "diet_type": "${dietType == 'None' ? 'None' : dietType}",
    "ingredients": ["200g ingredient", "1 tbsp ingredient"],
    "instructions": ["Step 1", "Step 2", "Step 3"],
    "nutrition": {
      "protein": 35.5,
      "carbs": 12.0,
      "fat": 18.2,
      "fiber": 3.5,
      "sugar": 2.1
    },
    "tags": ["tag1", "tag2"],
    "image_search_term": "descriptive food image search"
  }
]
''';
  }

  List<GeneratedMeal> _parseMealsFromResponse(String response) {
    try {
      // Find JSON array in response
      final startIndex = response.indexOf('[');
      final endIndex = response.lastIndexOf(']');

      if (startIndex == -1 || endIndex == -1 || endIndex <= startIndex) {
        return [];
      }

      final jsonStr = response.substring(startIndex, endIndex + 1);
      final List<dynamic> jsonList = jsonDecode(jsonStr);

      return jsonList
          .map((json) => GeneratedMeal.fromJson(json as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('Error parsing meals: $e');
      return [];
    }
  }

  Future<String> _makeRequest(String prompt) async {
    if (!hasApiKey) {
      throw Exception('API key not set. Add your API key in Chef AI settings.');
    }

    // Handle Gemini differently as it uses a different API format
    if (_provider == AIProviderType.gemini) {
      return await _makeGeminiRequest(prompt);
    }

    // OpenAI-compatible providers (OpenRouter, OpenAI, DeepSeek)
    return await _makeOpenAICompatibleRequest(prompt);
  }

  Future<String> _makeOpenAICompatibleRequest(String prompt) async {
    final baseUrl = _provider.baseUrl;
    final model = _provider.defaultModel;

    try {
      final headers = {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer $_apiKey',
      };

      // Add OpenRouter-specific headers
      if (_provider == AIProviderType.openRouter) {
        headers['HTTP-Referer'] = 'https://mealplanner.app';
        headers['X-Title'] = 'Meal Planner App';
      }

      final response = await http.post(
        Uri.parse(baseUrl),
        headers: headers,
        body: jsonEncode({
          'model': model,
          'messages': [
            {'role': 'user', 'content': prompt},
          ],
          'max_tokens': 3000,
          'temperature': 0.8,
        }),
      );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        return data['choices'][0]['message']['content'] ?? '';
      } else if (response.statusCode == 401) {
        throw Exception(
          'Invalid API key. Please check your key and try again.',
        );
      } else if (response.statusCode == 429) {
        throw Exception('Rate limit exceeded. Please try again later.');
      } else if (response.statusCode >= 500) {
        throw Exception(
          'AI service temporarily unavailable. Please try again.',
        );
      } else {
        final error = jsonDecode(response.body);
        throw Exception(error['error']?['message'] ?? 'Unknown error occurred');
      }
    } catch (e) {
      if (e.toString().contains('SocketException')) {
        throw Exception('Network error. Please check your connection.');
      }
      rethrow;
    }
  }

  Future<String> _makeGeminiRequest(String prompt) async {
    try {
      final url = '${_provider.baseUrl}?key=$_apiKey';

      final response = await http.post(
        Uri.parse(url),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({
          'contents': [
            {
              'parts': [
                {'text': prompt},
              ],
            },
          ],
          'generationConfig': {'temperature': 0.8, 'maxOutputTokens': 3000},
        }),
      );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        return data['candidates']?[0]?['content']?['parts']?[0]?['text'] ?? '';
      } else if (response.statusCode == 401 || response.statusCode == 403) {
        throw Exception('Invalid API key. Please check your Gemini key.');
      } else if (response.statusCode == 429) {
        throw Exception('Rate limit exceeded. Please try again later.');
      } else {
        final error = jsonDecode(response.body);
        throw Exception(error['error']?['message'] ?? 'Gemini API error');
      }
    } catch (e) {
      if (e.toString().contains('SocketException')) {
        throw Exception('Network error. Please check your connection.');
      }
      rethrow;
    }
  }

  /// Send a raw prompt and get the response (for personalization, custom uses)
  Future<String?> sendRawPrompt(String prompt) async {
    try {
      return await _makeRequest(prompt);
    } catch (e) {
      print('Error sending raw prompt: $e');
      return null;
    }
  }
}
